from fastapi import FastAPI, Request, Path, HTTPException
import uvicorn
import os
import time
app=FastAPI()
from langchain_openai import ChatOpenAI
from langchain.memory.buffer import ConversationBufferMemory
from langchain.chains.conversation.base import ConversationChain
from langchain_core.prompts import PromptTemplate
from fastapi.templating import Jinja2Templates
from fastapi.responses import HTMLResponse
from langchain_community.utilities import SQLDatabase
from sqlalchemy import create_engine
import pandas as pd
import os
from dotenv import load_dotenv
load_dotenv()
OPENAI_API_KEY=os.getenv("OPENAI_API_KEY")
llm = ChatOpenAI(
    model="gpt-4o",
    temperature=0
)
# Initialize ConversationBufferMemory
memory = ConversationBufferMemory(
    session_id="your_session_id",  # Identifies your user or a user's session
    memory_key="history",          # Ensure this matches the key used in chain's prompt template
    return_messages=True,          # Does your prompt template expect a string or a list of Messages?
)
# # Wrap the SQL Query Chain with a ConversationChain
# # , chain=chain_sql
prompt3 = PromptTemplate(
    template="""The following is a friendly conversation between a human and an AI. The AI is smart, technical, understands and generates sql queries, talkative, provides lots of specific details from its context and replies to Human in SQL language. When human asks a question to AI or send a query to the AI, the AI refers to a table named 'asian_paints' to generate the sql query for the reply. The AI is also given 7 columns, column's datatype and example values of the columns of the table asian_paints seperated by comma as following:
    1. Region, object, 'Region 1'
    2. Pincode, int64, '123456'
    3. Date, datetime64[ns], '2024-06-04 00:00:00.000000'
    4. Skues, object, 'SKU1'
    5. Demand, int64, 250000
    6. Inventory, int64, 50000
    7. Sales, int64, 270000
    The AI should also check if the syntax of SQL query The AI generated is correct or not to run it on sqlite db for results. In case of date filters present in query, the format of dates have only date values not time e.g. 'YYYY-MM-DD'. Change the format of these date values to default python tiemstamp datetime64[ns], e.g. '2024-06-04 00:00:00.000000'.
    If the AI does not know the answer to a question, it truthfully says it does not know. Use the following format:
    response: SQL Query generated by the AI as reply to Human

Current conversation:
{history}
Human: {input}
AI Assistant:
""",
    input_variables=["input", "history"]
)
conversation_chain = ConversationChain(llm=llm,prompt=prompt3, memory=memory,verbose=True)
######### Data import to be queried upon ###########
df = pd.read_excel('C:/Users/suraj/OneDrive/Desktop/Personal/bhole/gen-AI/limechat/asian_paint/Sample Data.xlsx',sheet_name='Sheet1')
engine = create_engine("sqlite:///asian_paints.db")
db = SQLDatabase(engine=engine)
# @app.get('/')
# def index():
#     return {'Welcome':'Search Engine Asian Paints'}

@app.get('/search_report_generation')
def report_generation(nlq: str):
    time_s=time.time()

    output = conversation_chain.predict(input=nlq)
    o2 = output.split('```sql\n')[-1]
    final_output = o2.split('\n```')[0]
    final_output2 = '```'+final_output+'```'
    final_output2 = final_output2.replace('\n', ' ')
    final_output2 = final_output2.replace('```', '')
    result = db.run(final_output)
    elapsed_time = time.time() - time_s
    print(f"Execution time: {elapsed_time} seconds")
    return final_output2, result
templates = Jinja2Templates(directory="C:/Users/suraj/OneDrive/Desktop/Personal/bhole/gen-AI/limechat/asian_paint")
@app.get("/", response_class=HTMLResponse)
async def read_root(request: Request):
    # Render the HTML template
    return templates.TemplateResponse("index.html", {"request": request})
if __name__=='__main__':
    uvicorn.run("api:app", host='localhost', port=7000, reload=False, workers=1)